# 构造数据抽象

上一章节讲的是，将一些过程复合起来，然后以这种方式去构建不同的抽象，在这一章节里面使用复合数据结构来构造抽象。

使用复合对象的好处，抽象级别比基本对象搞一个档次，可以更加抽象问题去解决。而不是局限于数值和字符。也可以进一步提高系统的模块性。

最基本的数据结构就是对偶（pair）

如果可以吧有理数当做对象处理，就有可能吧处理的程序部分和有理数如何表示隔离开，增强了模块化

一旦传入的参数不仅仅是基本类型，那么抽象涵盖的意义就大不一样的，就是一个可以无限解释的抽象。

## 数据导向的程序设计

允许孤立的设计每一种数据表示，然后用组合的形式来将他们组合起来。

## 数据抽象导引

认为规定数据格式，我认为你是这样就是这样，不是就不是。

## 抽象屏障

有理数里面有分子分母，别人在操作有理数的时候实际上是通过对象的api来操作。此时外部无需关心这个有理数里面有什么，这就是抽象屏障
对数据对象标识出一组操作（API）去操作数据对象，这样消费者就不用关心他内部的实现，

-----[使用有理数的程序]--------
    问题域中的有理数
------[addRat mulRat]--------
    作为分子或者分母的有理数
-------[makeRat number denmo]------
    作为序对的有理数
------[cons car cdr]-------
    序对也需要实现
如上图所示，这个抽象不仅仅是让用户不关心抽象内部的内容，而是让用户没有办法关心，就像一个屏障一样挡住了用户的好奇。

越是复杂的数据结构，都能以不同的方式以程序的基本语言构造出来。也是系统的模块化更加清晰。但是有个不足的地方就是使用一个数据结构，需要重构的时候
可能需要修改很多地方，这个时候就考研写的人的编码能力在程序上模块解耦度更加高，也就是不同模块之间的数据结构不能混用，不然会照成难以估计的后果。

### 懒加载的问题

在构建一个有理数的时候是构建的时候约分还是在访问分子分母的时候约分，这个其实考虑的是使用场景，如果场景访问分子分母要少一些的话，就访问的时候约分，反之在构建的时候约分。

## 数据

什么是数据：给定了构造方法和取值方法的对象？

>2.6

这个习题还是有点东西的，这里将数字抽象成了方法。
one = (add-1 zero)
(lambda (f)
    lambda (x)
        (f x))
two = (add-1 one)
(lambda (f)
    lambda (x)
        (f(f x)))
可见最后有多少个n就有多少个f

推出
three
给出加法定义：
(define +
    (lambda (m)
        (lambda (n)
            (lambda (f)
                (lambda (x)
                    ((m f) ((n f) x)))))))

这里不难解释出 (n f) = > (lambda x (f .. (f  x)) ) (n个f)
这里不难解释出 (m f) = > (lambda x (f .. (f  x)) ) (m个f)
最后合起来就是m + n个f 符合定义。

>2.13

这个在误差很小的情况下，无非就是，[1 - a% , 1 + b%]，然后条件又是大于1的，那么误差为 -2a + a ^ 2, + 2b + b ^ 2

>2.14

即便是在误差很小的时候A/A == 1都是不能成立的，所以这个lem说的不对

>2.15

对于区间的问题，越是使用区间去计算，越是会有一些问题，在1里面 R1 * R2/ R1 + R2 使用了R1R2两次。在part2里面定义了一个one [1 , 1] 已知 one / one / inerval1 = ineterval1 故 1/ (1 / R1 + 1 / R2 )

>2.16

如果要使区间计算准确，那么就需要消除误差，但是呢误差只要计算误差就存在。我觉得不行

解法1 ： 使用随机表，每个区间都生成随机表 这样同一个区间生成的随机表是一样的，那么相除就是1.

但是重点是消除依赖，所以就会有一种文体，就是需要在各种情况下做各种判断才行。

## 层次性数据和闭包

闭包：一集元素在某个运算下面封闭。

某种组合的数据结构的操作满足闭包性质，他们组合得到的对象能再次组合。

组合式的子项可以是组合式

nil： 什么都没有

### map相当于是js的map

>22

第二种传入的参数不是单纯的数字而是一个list 而list开头应该是一个数字，故可以使用reserve去翻转list

## 树

前面讲到了一种数据结构是序对，我们可以通过这个区构建list，也可以去构建tree，序对是最基础的数据结构了吧

>29

最后面问到了需要修改多少才能保证源程序的正确执行，其实不需要改多少，只需要改几个基础方法让他们返回与原来一样的结果就好了

## 使用约定的界面

找出两个过程的共性

例如：
1 计算一棵树里面值为奇数的叶子的平方和 枚举树叶->过滤->平方->累加
2 计算小于n的所有fib数的一个表 枚举fib -> 过滤->cons
其实在过程上他们是有一些共性的

抽象成一个过程的前提就是你能规整每个调用过程之前的数据结构，也就是在信号流动的时候无需做额外的修改，就能满足信号流动的条件

平时工作的时候基本没有碰到这个问题，原因是ts的数据结构方便调整，也就是因为这个问题，经常有数据转化的，在一个大的系统里面如果么有提前设计

那么这个问题是肯定有的只是问题的多少而已。一定会有大量的转换代码存在，我们要做的是在设计阶段尽可能将数据结构设计的通用和

以上两个过程原来的代码是不清晰的，因为模块化做的不够好，导致不够清晰，现在在这些逻辑都抽象成一个步骤，而不是将逻辑穿插在一起。

以第一个为例

原来的逻辑 ：递归中夹杂这判断，因为有树这个数据结构，所以不面会有递归

按照这个系列化的逻辑修改：

递归枚举出所有的叶子节点返回一个list ->  将list里面的奇数过滤出来返回一个list -> 对这个list里面每个元素求平方 -> 然后累加这个list里面所有的结果

这样靠list作为步骤之间的参数传递 会使代码量增加，效率降低，但是这只是对一个方法来说的，或许会降低效率，但是对一个系统来说，模块化非常重要。git

## 分层设计

一个系统应该是分为不同的层次的来构造出来

优点是分层设计里面应该修改一个基础组件的时候不需要修改其他的地方，

### 哈夫曼树

根的权重是子树权重的和，频度越高的字在树上离根越近

### 数据导向的程序设计复数

例如一个。复数有连两种表示情况，一种是直角坐标一种是极坐标，为了能通用他们的计算，在复数操作包里面我们只关心
复数的一些计算，所以两种表示要有所区别解决方法是在list里面加个tag，来区分这两者，计算的时候，实现不变，
计算的时候会去取值，只需要修改取值的方法就行了，兼容两种操作的取值方式。

### 模块化的设计

开始不是和理解他的设计，设计的基础是使用一个映射将所有的方法映射出去，然后通过一个apply方法来调用，这样就不用
关心方法的名字是否重复了。
如果是数据导向的程序设计，那么数据一定要是准确的是信息量足够的。

### 设计通用的有理数计算过程

在计算两个数之间的操作的时候，需要有个分发的方法，分发的依据是数据李=里面的tag，例如复数就是加法 直接调用applygenergic
方法就行了，通过分发的方法来去操作，这个和元数据里面是一样的，通过reader去读取，是文件系统就使用fs的实现，如果是数据库系统
就是用db的实现。

这个系统的设计方式，核心就是这个分发方法，和数据结构的设计，例如复数(complex rec x y)第一个tag表示他是复数，第二个表示
是直角坐标形式表示。

提供一个操作的方法出来操作数据，这个就是面向接口的设计。只是不像java一样有interface而已。

