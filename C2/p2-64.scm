(load "p2-63")
(define (list2tree elements)
    (car (partical elements (length elements)))
)
(define (partical elements n)
    (if (= n 0)
        (cons '() elements)
        (let ((leftsize (quotient (- n 1) 2)))
            (let ((leftres (partical elements leftsize)))
                (let ((lefttree (car leftres))
                    (nonleftelements (cdr leftres))
                    (rightsize (- n (+ leftsize 1))))
                    (let ((thisentry (car nonleftelements))
                    (rightres (partical (cdr nonleftelements) rightsize)))
                        (let ((righttree (car rightres))
                        (remainelements (cdr rightres)))
                            (cons (make-tree thisentry lefttree righttree) remainelements)
                        )
                    ))
                ))
            )
        )
(define a (list 1 3 5 7 9 11))
;a> 为什么能完成这个工作，list是一个有序的集合，然后在构建的时候不断的吧前面的元素组合成树就行了结构是：
;(1 3 5 7 9 11)
;(1) + () +((3 () ()) 5 7 9 11)
;(5) + (1 () (3 () ())) (9 7 11))
;n