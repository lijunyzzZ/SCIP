; 生成 i-j的序对满足 i+j 为奇数
; 枚举 i - j 的list
(define (eni l h)
    (if (> l h) '() (cons l (eni (+ l 1) h)))
)
(define (prime n) (= (findDivisor n 2) n))
(define (square x) (* x x))
(define (isRem n x) (= (remainder n x) 0))
(define (findDivisor n index)
(cond 
   ( (> (square index) n) n)
   ((isRem n index) index)
   (else (findDivisor n (+ index 1)))
)
)
(load "p2-37")
(define (flatmap proc seq)
    (accumulate append '() (map proc seq))
)
(define (prime-sum? pair)
    (prime (+ (car pair) (cadr pair)))
)
(define (make-pair-sum pair)
    (list (car pair) (cadr pair) (+ (car pair) (cadr pair)) )
)
(define (prime-sum-pairs n)
    (map make-pair-sum
     (filter prime-sum? 
        (flatmap (lambda (i) 
        (map (lambda (j) (list i j)) 
            (eni 1 (- i 1))
        ))
        (eni 1 n)
    )))
)
(define (per s) 
    (if (null? s) (list '()) 
    (flatmap (lambda (x) 
        (map (lambda (p)
            (cons x p)
        )
        (per (remove x s))
        )
    )
    s))
)
(define (remove item seq)
    (filter (lambda (x) (not (= x item))) seq)
)
(define s (list 1 2 3))
