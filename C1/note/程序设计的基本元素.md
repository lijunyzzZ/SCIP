# 构造过程的抽象

## 过程是一个黑箱抽象

其含义是对于使用你这个过程或者是方法的开发者或者用户来说，这个他使用这个方法的时候是不关心这个过程的内部实现的。说白了只是关心输入或者输出。

>书中说：可以将求平方根的程序分解成几个子程序。

其实一个系统也是如此，可以分解成若干个子系统或者是子模块。各个模块分工处理任务，只有职责分解清晰，那么代码也是清晰的。

>过程的意义不应该依赖形参的名字。

定义一个过程的时候，用户使用时形参是可以改变的，用这个来描述一个过程的意义是不现实的。

>形参应该只是被约束在一个过程里面。

形参其实不论叫什么都对一个过程不影响，但是定义一个过程，传入的值都会被被约束成这个变量。自由变量就相当于是全局的变量，而约束变量就是过程内部的变量。

## 内部定义和块结构

>什么是块结构

类比js的内部方法，一个有内部方法的func就是一个块结构，而内部方法就是他的内部定义。这样做的初衷是整合一个程序，只暴露一个输入接口。就类似java里面`privata` 我只让你看到你想看到的，目的在于不让用户困扰，例如他现在就像求平方根，那么只需要调用一个方法就行了。而不是
去操作各种improve func  good—enough方法。

## 过程和他们产生的抽象

>我现在处于的阶段

感觉现在我的编程水平感觉还是比较低的，处于知道规则但是没有设计思维。

>很重要的一点

了解各个过程中执行的结果，然后能够从某些结果里面找到最适合的解决方案，（感觉这个就是经验，其实不然，经验是怎么来的呢？说白了同样是5年和十年的程序员，也是会有不一样的结果）

>一个计算过程局部演化的方式

一个过程执行的时候就相当于描述了这一点。例如计算 6！ 的线性递归过程。我们应该尝试自己手动去执行代码。这个有助于我们理解O和T，时间复杂度和空间复杂度。

## 线性递归和迭代

这个是递归的方法：

```lisp
(defun factorial (n) 
    (if (= n 1) 1 (* n (factorial (- n 1))))
)
```

>线性递归

线性递归计算的时候总是从最后一层开始计算的。如果一个方法的计算层数太多了，超过了解释器的长度，一般会出错的。
在代换模型中，递归都是先展开然后收缩，从底层开始执行的，执行长度随着n值线性增长的叫做线性递归。

迭代：

```lisp
(defun factorial-iter (x count n)
    (if (> count n)
        x
        (factorial-iter (* x count) (+ count 1) n))
)
```

>迭代

迭代是每一步都保存了计算内容的有状态值记录，中断了还能再开始。

