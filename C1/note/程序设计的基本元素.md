# 构造过程的抽象

## 过程是一个黑箱抽象

其含义是对于使用你这个过程或者是方法的开发者或者用户来说，这个他使用这个方法的时候是不关心这个过程的内部实现的。说白了只是关心输入或者输出。
>书中说：可以将求平方根的程序分解成几个子程序

很简单的一道题

>practice 1.12



其实一个系统也是如此，可以分解成若干个子系统或者是子模块。各个模块分工处理任务，只有职责分解清晰，那么代码也是清晰的。

>过程的意义不应该依赖形参的名字。

定义一个过程的时候，用户使用时形参是可以改变的，用这个来描述一个过程的意义是不现实的。

>形参应该只是被约束在一个过程里面。

形参其实不论叫什么都对一个过程不影响，但是定义一个过程，传入的值都会被被约束成这个变量。自由变量就相当于是全局的变量，而约束变量就是过程内部的变量。

## 内部定义和块结构

>什么是块结构

类比js的内部方法，一个有内部方法的func就是一个块结构，而内部方法就是他的内部定义。这样做的初衷是整合一个程序，只暴露一个输入接口。就类似java里面`privata` 我只让你看到你想看到的，目的在于不让用户困扰，例如他现在就像求平方根，那么只需要调用一个方法就行了。而不是
去操作各种improve func  good—enough方法。

## 过程和他们产生的抽象

>我现在处于的阶段

感觉现在我的编程水平感觉还是比较低的，处于知道规则但是没有设计思维。

>很重要的一点

了解各个过程中执行的结果，然后能够从某些结果里面找到最适合的解决方案，（感觉这个就是经验，其实不然，经验是怎么来的呢？说白了同样是5年和十年的程序员，也是会有不一样的结果）

>一个计算过程局部演化的方式

一个过程执行的时候就相当于描述了这一点。例如计算 6！ 的线性递归过程。我们应该尝试自己手动去执行代码。这个有助于我们理解O和T，时间复杂度和空间复杂度。

## 线性递归和迭代

这个是递归的方法：

```lisp
(defun factorial (n) 
    (if (= n 1) 1 (* n (factorial (- n 1))))
)
```

>线性递归

线性递归计算的时候总是从最后一层开始计算的。如果一个方法的计算层数太多了，超过了解释器的长度，一般会出错的。
在代换模型中，递归都是先展开然后收缩，从底层开始执行的，执行长度随着n值线性增长的叫做线性递归。

迭代：

```lisp
(defun factorial-iter (x count n)
    (if (> count n)
        x
        (factorial-iter (* x count) (+ count 1) n))
)
```

>迭代

迭代是每一步都保存了计算内容的有状态值记录，中断了还能再开始。

>practice 1.9

第一个是线性递归因为他在替换模型里面是先增大的然后再减小的。

第二个是迭代 a ，b 保存了状态。

>practive 1.10

找规律的时候可以使用归纳法，这道题目我做对了

## 树形递归

像斐波那契那种一个计算里面调用自己两次的递归。最终的计算结果往往是一个树形的展开。此时可以使用迭代来减少这种不必要的计算

```lisp
(defun fib (n)
    (fib-iter 1 0 n)
)
(defun fib-iter (a b count)
    (if (= count 0) b
        (fib-iter (+ a b) a (- count 1)))
)
(print (fib 14))
```

树形递归显然是不如迭代的计算步数少的，但是，树形递归是一个看起来比较易懂的编程手段。
这个地方可以使用控件换时间，例如将计算的值存储起来。不过这是编译时期的优化了。

>practice 1.11

很简单的一道题

>practice 1.12 翻译有误 是求出各个位置的值。

这个算法的迭代需要了解的是，一个帕斯卡三角的另一种阶乘的公式。

>practice 1.13

用归纳法解决。

## 增长的阶

时间空间复杂度

表示的是在输入的值变大的时候某一个计算过程的所需资源的变化。输入的值一般用n表示，这个n表示了一个过程的输入的函数需要计算的那个数。对于矩阵乘法这个n对应的就是矩阵的行数。

对于迭代的递归实现，步数的增长为O(n)空间的增长为O(n)，迭代的步数的增长是O(n),空间的增长为O(1)

增长的阶的表示方法是很粗略的。例如一个增长的步数需要：3*n^2 + 2* n+ 17，用O表示就是O(n^2)

如果是常数型，那么在入参资源变大的时候计算的步数不会增长，如果是n那么是线性增长的，如果是指数型，那么就是n每增加1带来的增长就是几何倍数。如果是对数型，那么增长一倍的n，只会带来常数级别n的增长。

>practice 1.14

在求增长的阶的时候theta的时候，要去了解怎么拆分步骤：

例如十块钱分为由 1分 5分 10分 25分  50分构成的零钱

下列表达式表示的是： T(10 5) 10块分5种类型的币种应该是多少种

T(10 5) = T(9.99 5) +  T(10 4)

T(9.99 5) = T(9.98 5) + T(9.99 4)

往下拆分就有1000个分支（10/0.01）
所以这个：T(n 4) = n T(n 4)

以此类推：(T 1000 5) = n *  ( n/5 * ( n/10 * ( n/25 * (n/50))))
化简之后就是n5；


